package icu.nyat.kusunoki.deenchantment.nms.@NMS_PACKAGE@;

import icu.nyat.kusunoki.deenchantment.nms.NmsBridge;
import io.papermc.paper.registry.legacy.DelayedRegistry;
import net.minecraft.core.Holder;
import net.minecraft.core.Holder.Reference;
import net.minecraft.core.HolderSet;
import net.minecraft.core.MappedRegistry;
import net.minecraft.core.Registry;
import net.minecraft.core.registries.Registries;
import net.minecraft.resources.ResourceLocation;
import org.bukkit.Bukkit;
import org.bukkit.NamespacedKey;
import org.bukkit.craftbukkit.CraftRegistry;
import org.bukkit.craftbukkit.CraftServer;
import org.bukkit.craftbukkit.util.CraftNamespacedKey;
import org.bukkit.enchantments.Enchantment;
import org.bukkit.craftbukkit.enchantments.CraftEnchantment;

import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.util.IdentityHashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.function.BiFunction;
import java.util.logging.Level;
import javax.annotation.Nullable;

/**
 * Modern (@MINECRAFT_VERSION_LABEL@) bridge that mirrors EcoEnchants' registry replacement so we
 * can inject custom enchantments despite Bukkit removing
 * {@code Enchantment.registerEnchantment}.
 */
final class ModernNmsBridge implements NmsBridge {

    private final CraftServer craftServer = (CraftServer) Bukkit.getServer();
    private final Registry<net.minecraft.world.item.enchantment.Enchantment> nmsRegistry;
    private final org.bukkit.Registry<Enchantment> bukkitRegistry;
    private final Map<NamespacedKey, Enchantment> registered = new ConcurrentHashMap<>();
    private final Field frozenField;
    private final Field allTagsField;
    private final Field unregisteredIntrusiveHoldersField;
    private final Field minecraftToBukkitField;
    private final Field cacheField;
    private final Object originalMapper;
    private final Constructor<?> registryTypeMapperConstructor;
    private volatile boolean registryRemapped;

    ModernNmsBridge() {
        this.nmsRegistry = lookupRegistry();
        this.bukkitRegistry = lookupBukkitRegistry();
        try {
            // Get the actual MappedRegistry class - might be wrapped
            final Class<?> registryClass = findMappedRegistryClass(nmsRegistry);
            this.frozenField = locateFrozenField(registryClass);
            this.allTagsField = locateAllTagsField(registryClass);
            this.unregisteredIntrusiveHoldersField = locateUnregisteredField(registryClass);
            this.minecraftToBukkitField = locateField(CraftRegistry.class, "minecraftToBukkit");
            this.cacheField = locateField(CraftRegistry.class, "cache");
            this.originalMapper = minecraftToBukkitField.get(bukkitRegistry);
            this.registryTypeMapperConstructor = locateRegistryTypeMapper();
        } catch (final ReflectiveOperationException exception) {
            throw new IllegalStateException("Unable to initialize NMS bridge", exception);
        }
    }

    @Override
    public void prepareRegistration() {
        ensureRegistryMapper();
        clearBukkitCache();
        unfreezeRegistry();
    }

    @Override
    public boolean register(final Enchantment enchantment) {
        if (enchantment == null) {
            return false;
        }

        final NamespacedKey key = enchantment.getKey();
        registered.put(key, enchantment);

        final ResourceLocation minecraftKey = CraftNamespacedKey.toMinecraft(key);
        if (registryContainsKey(minecraftKey)) {
            return true;
        }

        try {
            final net.minecraft.world.item.enchantment.Enchantment vanillaLike = createVanillaLikeEnchantment(enchantment);
            invokeCreateIntrusiveHolder(vanillaLike);
            registryRegister(minecraftKey, vanillaLike);
            return true;
        } catch (final Throwable error) {
            Bukkit.getLogger().log(Level.WARNING, "Failed to register enchantment " + key + " via modern bridge", error);
            registered.remove(key);
            return false;
        }
    }

    @Override
    public void freezeRegistration() {
        invokeFreeze();
    }

    @Override
    public void unregisterAll() {
        registered.clear();
        clearBukkitCache();
    }

    @Override
    public boolean supportsHardReset() {
        return false;
    }

    @SuppressWarnings("unchecked")
    private Registry<net.minecraft.world.item.enchantment.Enchantment> lookupRegistry() {
        // In 1.21+, registryAccess().lookupOrThrow() returns a HolderLookup.RegistryLookup (MappedRegistry$1)
        // which is NOT a Registry. We need to get the actual WritableRegistry.
        final Object lookup = craftServer.getServer()
                .registryAccess()
                .lookupOrThrow(Registries.ENCHANTMENT);
        
        // Try to extract the actual registry from the lookup wrapper
        return extractRegistry(lookup);
    }
    
    @SuppressWarnings("unchecked")
    private Registry<net.minecraft.world.item.enchantment.Enchantment> extractRegistry(final Object lookup) {
        // If it's already a Registry, return it
        if (lookup instanceof Registry) {
            return (Registry<net.minecraft.world.item.enchantment.Enchantment>) lookup;
        }
        
        // The lookup is likely MappedRegistry$1 (an anonymous inner class)
        // Try to find the outer MappedRegistry instance via reflection
        try {
            // Anonymous inner classes have a reference to their enclosing instance
            // typically named "this$0"
            for (final Field field : lookup.getClass().getDeclaredFields()) {
                if (field.getName().startsWith("this$") || 
                    Registry.class.isAssignableFrom(field.getType()) ||
                    field.getType().getName().contains("MappedRegistry")) {
                    field.setAccessible(true);
                    final Object value = field.get(lookup);
                    if (value instanceof Registry) {
                        return (Registry<net.minecraft.world.item.enchantment.Enchantment>) value;
                    }
                }
            }
            
            // If we couldn't find it via fields, try to get it from BuiltInRegistries
            // or the server's registry access differently
            final var registryAccess = craftServer.getServer().registryAccess();
            for (final Method method : registryAccess.getClass().getMethods()) {
                if (method.getName().equals("registry") || method.getName().equals("registryOrThrow")) {
                    if (method.getParameterCount() == 1) {
                        method.setAccessible(true);
                        final Object result = method.invoke(registryAccess, Registries.ENCHANTMENT);
                        if (result instanceof Registry) {
                            return (Registry<net.minecraft.world.item.enchantment.Enchantment>) result;
                        }
                        // Might be Optional<Registry>
                        if (result instanceof java.util.Optional<?> optional && optional.isPresent()) {
                            final Object inner = optional.get();
                            if (inner instanceof Registry) {
                                return (Registry<net.minecraft.world.item.enchantment.Enchantment>) inner;
                            }
                        }
                    }
                }
            }
        } catch (final ReflectiveOperationException e) {
            throw new IllegalStateException("Unable to extract registry from lookup: " + lookup.getClass().getName(), e);
        }
        
        throw new IllegalStateException("Unable to find Registry from lookup object: " + lookup.getClass().getName() + 
            " (implements: " + java.util.Arrays.toString(lookup.getClass().getInterfaces()) + ")");
    }
    
    /**
     * Finds the actual MappedRegistry class, handling wrapper/anonymous classes.
     */
    private static Class<?> findMappedRegistryClass(final Object registry) {
        Class<?> clazz = registry.getClass();
        // Walk up the hierarchy to find MappedRegistry
        while (clazz != null && clazz != Object.class) {
            if (clazz.getName().equals("net.minecraft.core.MappedRegistry")) {
                return clazz;
            }
            // Check if it's an anonymous inner class of MappedRegistry
            if (clazz.getEnclosingClass() != null && 
                clazz.getEnclosingClass().getName().equals("net.minecraft.core.MappedRegistry")) {
                return clazz.getEnclosingClass();
            }
            clazz = clazz.getSuperclass();
        }
        // Fallback to the actual class
        return registry.getClass();
    }

    @SuppressWarnings("unchecked")
    private org.bukkit.Registry<Enchantment> lookupBukkitRegistry() {
        final org.bukkit.Registry<Enchantment> registry = org.bukkit.Registry.ENCHANTMENT;
        
        // In newer Paper versions, it might be WritableCraftRegistry directly
        // In older versions, it's wrapped in DelayedRegistry
        if (registry instanceof DelayedRegistry<Enchantment, ?> delayed) {
            return delayed.delegate();
        }
        
        // For WritableCraftRegistry or CraftRegistry, return directly
        return registry;
    }

    @SuppressWarnings({"rawtypes", "unchecked"})
    private void ensureRegistryMapper() {
        if (registryRemapped) {
            return;
        }
        synchronized (this) {
            if (registryRemapped) {
                return;
            }
            try {
                final Object mapper = createRegistryMapperBridge();
                minecraftToBukkitField.setAccessible(true);
                minecraftToBukkitField.set(bukkitRegistry, mapper);
                registryRemapped = true;
            } catch (final ReflectiveOperationException exception) {
                throw new IllegalStateException("Unable to replace CraftRegistry mapper", exception);
            }
        }
    }

    private BiFunction<NamespacedKey, net.minecraft.world.item.enchantment.Enchantment, Enchantment> createMapperFunction() {
        return (key, value) -> {
            final Enchantment custom = registered.get(key);
            if (custom != null) {
                return custom;
            }
            return applyOriginalMapper(key, value);
        };
    }

    private void unfreezeRegistry() {
        try {
            if (frozenField != null) {
                frozenField.setBoolean(nmsRegistry, false);
            }
            if (unregisteredIntrusiveHoldersField != null) {
                unregisteredIntrusiveHoldersField.set(
                    nmsRegistry,
                    new IdentityHashMap<net.minecraft.world.item.enchantment.Enchantment, Reference<net.minecraft.world.item.enchantment.Enchantment>>()
                );
            }
            if (allTagsField != null) {
                final Object tagSet = createUnboundTagSet(nmsRegistry.getClass());
                if (tagSet != null) {
                    allTagsField.set(nmsRegistry, tagSet);
                }
            }
        } catch (final IllegalAccessException exception) {
            throw new IllegalStateException("Unable to unfreeze enchantment registry", exception);
        }
    }

    private Object createUnboundTagSet(final Class<?> registryClass) {
        // Find the actual MappedRegistry class for inner classes
        Class<?> mappedRegistryClass = registryClass;
        while (mappedRegistryClass != null && !mappedRegistryClass.getName().equals("net.minecraft.core.MappedRegistry")) {
            if (mappedRegistryClass.getEnclosingClass() != null &&
                mappedRegistryClass.getEnclosingClass().getName().equals("net.minecraft.core.MappedRegistry")) {
                mappedRegistryClass = mappedRegistryClass.getEnclosingClass();
                break;
            }
            mappedRegistryClass = mappedRegistryClass.getSuperclass();
        }
        if (mappedRegistryClass == null) {
            mappedRegistryClass = MappedRegistry.class;
        }
        
        final Class<?>[] innerClasses = mappedRegistryClass.getDeclaredClasses();
        if (innerClasses.length == 0) {
            // No inner classes found - return null to skip tag set update
            return null;
        }
        final Class<?> helper = innerClasses[0];
        for (final Method method : helper.getDeclaredMethods()) {
            if (!Modifier.isStatic(method.getModifiers()) || method.getParameterCount() != 0) {
                continue;
            }
            method.setAccessible(true);
            try {
                return method.invoke(null);
            } catch (final ReflectiveOperationException ignored) {
                // Try the next method.
            }
        }
        throw new IllegalStateException("Unable to construct tag set for enchantment registry");
    }

    private net.minecraft.world.item.enchantment.Enchantment createVanillaLikeEnchantment(final Enchantment enchantment) {
        final int weight = Math.max(1, enchantment.getWeight());
        final int maxLevel = Math.max(1, enchantment.getMaxLevel());
        final int minCost = Math.max(1, enchantment.getMinModifiedCost(enchantment.getStartLevel()));
        final int maxCost = Math.max(minCost, enchantment.getMaxModifiedCost(maxLevel));
        final int anvilCost = Math.max(0, enchantment.getAnvilCost());

        final net.minecraft.world.item.enchantment.Enchantment.EnchantmentDefinition definition = net.minecraft.world.item.enchantment.Enchantment.definition(
            HolderSet.empty(),
                weight,
                maxLevel,
                net.minecraft.world.item.enchantment.Enchantment.constantCost(minCost),
                net.minecraft.world.item.enchantment.Enchantment.constantCost(maxCost),
                anvilCost
        );

        return net.minecraft.world.item.enchantment.Enchantment.enchantment(definition)
                .build(CraftNamespacedKey.toMinecraft(enchantment.getKey()));
    }

    private void clearBukkitCache() {
        try {
            cacheField.set(bukkitRegistry, new ConcurrentHashMap<NamespacedKey, Enchantment>());
        } catch (final IllegalAccessException exception) {
            throw new IllegalStateException("Unable to clear CraftRegistry cache", exception);
        }
    }

    private Object createRegistryMapperBridge() {
        final BiFunction<NamespacedKey, net.minecraft.world.item.enchantment.Enchantment, Enchantment> mapperFunction = createMapperFunction();
        if (registryTypeMapperConstructor == null) {
            return mapperFunction;
        }
        try {
            return registryTypeMapperConstructor.newInstance(mapperFunction);
        } catch (final ReflectiveOperationException exception) {
            throw new IllegalStateException("Unable to instantiate RegistryTypeMapper bridge", exception);
        }
    }

    @SuppressWarnings("unchecked")
    private Enchantment applyOriginalMapper(final NamespacedKey key, final net.minecraft.world.item.enchantment.Enchantment value) {
        if (originalMapper == null) {
            return null;
        }
        if (originalMapper instanceof BiFunction<?, ?, ?> function) {
            return ((BiFunction<NamespacedKey, net.minecraft.world.item.enchantment.Enchantment, Enchantment>) function).apply(key, value);
        }
        try {
            final Method applyMethod = originalMapper.getClass().getMethod("apply", Object.class, Object.class);
            applyMethod.setAccessible(true);
            return (Enchantment) applyMethod.invoke(originalMapper, key, value);
        } catch (final ReflectiveOperationException exception) {
            throw new IllegalStateException("Unable to delegate to original CraftRegistry mapper", exception);
        }
    }

    /**
     * Invokes createIntrusiveHolder via reflection to handle wrapper registry classes.
     */
    private void invokeCreateIntrusiveHolder(final net.minecraft.world.item.enchantment.Enchantment enchantment) {
        try {
            Method method = null;
            Class<?> clazz = nmsRegistry.getClass();
            while (clazz != null && clazz != Object.class) {
                for (final Method m : clazz.getDeclaredMethods()) {
                    if (m.getName().equals("createIntrusiveHolder") && m.getParameterCount() == 1) {
                        method = m;
                        break;
                    }
                }
                if (method != null) break;
                clazz = clazz.getSuperclass();
            }
            if (method == null) {
                throw new IllegalStateException("Unable to locate createIntrusiveHolder method");
            }
            method.setAccessible(true);
            method.invoke(nmsRegistry, enchantment);
        } catch (final ReflectiveOperationException exception) {
            throw new IllegalStateException("Unable to invoke createIntrusiveHolder", exception);
        }
    }

    /**
     * Invokes freeze via reflection to handle wrapper registry classes.
     */
    private void invokeFreeze() {
        try {
            Method method = null;
            Class<?> clazz = nmsRegistry.getClass();
            while (clazz != null && clazz != Object.class) {
                for (final Method m : clazz.getDeclaredMethods()) {
                    if (m.getName().equals("freeze") && m.getParameterCount() == 0) {
                        method = m;
                        break;
                    }
                }
                if (method != null) break;
                clazz = clazz.getSuperclass();
            }
            if (method == null) {
                throw new IllegalStateException("Unable to locate freeze method");
            }
            method.setAccessible(true);
            method.invoke(nmsRegistry);
        } catch (final ReflectiveOperationException exception) {
            throw new IllegalStateException("Unable to invoke freeze", exception);
        }
    }

    /**
     * Checks if the registry contains the given key via reflection.
     */
    private boolean registryContainsKey(final ResourceLocation key) {
        try {
            // Try containsKey method first
            Method method = null;
            Class<?> clazz = nmsRegistry.getClass();
            while (clazz != null && clazz != Object.class) {
                for (final Method m : clazz.getDeclaredMethods()) {
                    if (m.getName().equals("containsKey") && m.getParameterCount() == 1) {
                        method = m;
                        break;
                    }
                }
                if (method != null) break;
                clazz = clazz.getSuperclass();
            }
            if (method != null) {
                method.setAccessible(true);
                return (Boolean) method.invoke(nmsRegistry, key);
            }
            
            // Try get method and check for null
            clazz = nmsRegistry.getClass();
            while (clazz != null && clazz != Object.class) {
                for (final Method m : clazz.getDeclaredMethods()) {
                    if (m.getName().equals("get") && m.getParameterCount() == 1 && 
                        m.getParameterTypes()[0].isAssignableFrom(ResourceLocation.class)) {
                        method = m;
                        break;
                    }
                }
                if (method != null) break;
                clazz = clazz.getSuperclass();
            }
            if (method != null) {
                method.setAccessible(true);
                return method.invoke(nmsRegistry, key) != null;
            }
            
            // Assume it doesn't exist if we can't check
            return false;
        } catch (final ReflectiveOperationException exception) {
            return false;
        }
    }

    /**
     * Registers an enchantment in the registry via reflection.
     */
    private void registryRegister(final ResourceLocation key, final net.minecraft.world.item.enchantment.Enchantment value) {
        // Try multiple approaches to register
        Throwable lastError = null;
        
        // Create ResourceKey
        Object resourceKey = null;
        try {
            final Class<?> resourceKeyClass = Class.forName("net.minecraft.resources.ResourceKey");
            final Method createMethod = resourceKeyClass.getMethod("create", resourceKeyClass, ResourceLocation.class);
            final Field enchantmentRegistryKey = Registries.class.getField("ENCHANTMENT");
            final Object registryKey = enchantmentRegistryKey.get(null);
            resourceKey = createMethod.invoke(null, registryKey, key);
        } catch (final ReflectiveOperationException e) {
            lastError = e;
        }
        
        // Get RegistrationInfo.BUILT_IN for 1.20.5+ style registration
        Object registrationInfo = null;
        try {
            final Class<?> registrationInfoClass = Class.forName("net.minecraft.core.RegistrationInfo");
            final Field builtInField = registrationInfoClass.getField("BUILT_IN");
            registrationInfo = builtInField.get(null);
        } catch (final ClassNotFoundException | NoSuchFieldException | IllegalAccessException e) {
            // RegistrationInfo doesn't exist in older versions, that's fine
        }
        
        // Approach 1: Try instance register method with 3 params (ResourceKey, Object, RegistrationInfo)
        if (resourceKey != null && registrationInfo != null) {
            try {
                Method method = null;
                Class<?> clazz = nmsRegistry.getClass();
                while (clazz != null && clazz != Object.class) {
                    for (final Method m : clazz.getDeclaredMethods()) {
                        if (m.getName().equals("register") && m.getParameterCount() == 3) {
                            method = m;
                            break;
                        }
                    }
                    if (method != null) break;
                    clazz = clazz.getSuperclass();
                }
                if (method != null) {
                    method.setAccessible(true);
                    method.invoke(nmsRegistry, resourceKey, value, registrationInfo);
                    return;
                }
            } catch (final ReflectiveOperationException e) {
                lastError = e;
            }
        }
        
        // Approach 2: Try instance register method with 2 params (ResourceKey, Object)
        if (resourceKey != null) {
            try {
                Method method = null;
                Class<?> clazz = nmsRegistry.getClass();
                while (clazz != null && clazz != Object.class) {
                    for (final Method m : clazz.getDeclaredMethods()) {
                        if (m.getName().equals("register") && m.getParameterCount() == 2) {
                            method = m;
                            break;
                        }
                    }
                    if (method != null) break;
                    clazz = clazz.getSuperclass();
                }
                if (method != null) {
                    method.setAccessible(true);
                    method.invoke(nmsRegistry, resourceKey, value);
                    return;
                }
            } catch (final ReflectiveOperationException e) {
                lastError = e;
            }
        }
        
        // Approach 3: Try Registry.register static method with ResourceLocation
        try {
            final Method registerMethod = Registry.class.getMethod("register", Registry.class, ResourceLocation.class, Object.class);
            registerMethod.invoke(null, nmsRegistry, key, value);
            return;
        } catch (final ReflectiveOperationException e) {
            lastError = e;
        }
        
        // Approach 4: Try Registry.register static method with ResourceKey
        if (resourceKey != null) {
            try {
                final Class<?> resourceKeyClass = Class.forName("net.minecraft.resources.ResourceKey");
                final Method registerMethod = Registry.class.getMethod("register", Registry.class, resourceKeyClass, Object.class);
                registerMethod.invoke(null, nmsRegistry, resourceKey, value);
                return;
            } catch (final ReflectiveOperationException e) {
                lastError = e;
            }
        }
        
        // Approach 5: Try Registry.register static method with String
        try {
            final Method registerMethod = Registry.class.getMethod("register", Registry.class, String.class, Object.class);
            registerMethod.invoke(null, nmsRegistry, key.toString(), value);
            return;
        } catch (final ReflectiveOperationException e) {
            lastError = e;
        }
        
        throw new IllegalStateException("Unable to locate register method for registry type: " + nmsRegistry.getClass().getName(), lastError);
    }

    private static Field locateFrozenField(final Class<?> registryClass) {
        // Search in the class and its superclasses
        Class<?> clazz = registryClass;
        while (clazz != null && clazz != Object.class) {
            for (final Field field : clazz.getDeclaredFields()) {
                if (field.getType() == boolean.class) {
                    field.setAccessible(true);
                    return field;
                }
            }
            clazz = clazz.getSuperclass();
        }
        throw new IllegalStateException("Unable to locate MappedRegistry#frozen field in " + registryClass.getName());
    }

    private static Field locateAllTagsField(final Class<?> registryClass) {
        Class<?> clazz = registryClass;
        while (clazz != null && clazz != Object.class) {
            for (final Field field : clazz.getDeclaredFields()) {
                final String typeName = field.getType().getName();
                final String fieldName = field.getName();
                // Look for TagSet, tags, or similar field names/types
                if (typeName.contains("TagSet") || 
                    typeName.contains("Tag") ||
                    fieldName.contains("tag") ||
                    fieldName.contains("Tag")) {
                    field.setAccessible(true);
                    return field;
                }
            }
            clazz = clazz.getSuperclass();
        }
        // If we can't find a tag field, return null - we'll handle it in unfreezeRegistry
        return null;
    }

    private static Field locateUnregisteredField(final Class<?> registryClass) {
        Class<?> clazz = registryClass;
        while (clazz != null && clazz != Object.class) {
            for (final Field field : clazz.getDeclaredFields()) {
                // Look for Map fields that could be the intrusive holders
                if (field.getType() == Map.class) {
                    // Check for @Nullable or field name hints
                    if (field.isAnnotationPresent(Nullable.class) ||
                        field.getName().contains("unregistered") ||
                        field.getName().contains("intrusive") ||
                        field.getName().contains("Holder")) {
                        field.setAccessible(true);
                        return field;
                    }
                }
            }
            clazz = clazz.getSuperclass();
        }
        // Second pass: just find any Map field with @Nullable
        clazz = registryClass;
        while (clazz != null && clazz != Object.class) {
            for (final Field field : clazz.getDeclaredFields()) {
                if (field.getType() == Map.class) {
                    field.setAccessible(true);
                    return field;
                }
            }
            clazz = clazz.getSuperclass();
        }
        // Return null if not found - we'll handle it
        return null;
    }

    private static Field locateField(final Class<?> owner, final String name) throws NoSuchFieldException {
        final Field field = owner.getDeclaredField(name);
        field.setAccessible(true);
        return field;
    }

    private static Constructor<?> locateRegistryTypeMapper() {
        try {
            final Class<?> mapperClass = Class.forName("io.papermc.paper.registry.entry.RegistryTypeMapper");
            final Constructor<?> constructor = mapperClass.getDeclaredConstructor(BiFunction.class);
            constructor.setAccessible(true);
            return constructor;
        } catch (final ClassNotFoundException | NoSuchMethodException exception) {
            return null;
        }
    }
}
